programs:
  - name: tcprtt
    metrics:
      histograms:
        - name: tcp_rtt
          help: TCP RTT
          table: hist_srtt
          bucket_type: exp2
          bucket_min: 1
          bucket_max: 10
          bucket_multiplier: 1
          labels:
            - name: addr
              size: 8
              decoders:
                - name: inet_ip
            - name: direction
              size: 8
              decoders:
                - name: uint
                - name: static_map
                  static_map:
                    1: source
                    2: destination
            - name: slot
              size: 8
              decoders:
                - name: uint
    kprobes:
      tcp_rcv_established: trace_tcp_rcv
    code: |
      #include <uapi/linux/ptrace.h>
      #include <linux/tcp.h>
      #include <net/sock.h>
      #include <net/inet_sock.h>
      #include <bcc/proto.h>

      typedef struct rtt_key {
        u64 addr;
        u64 direction;
        u64 slot;
      } rtt_key_t;

      // Histograms to record TCP RTT
      BPF_HISTOGRAM(hist_srtt, rtt_key_t, 1000000);

      #define SOURCE 1
      #define DESTINATION 2

      int trace_tcp_rcv(struct pt_regs *ctx, struct sock *sk, struct sk_buff *skb)
      {
        struct tcp_sock *ts = tcp_sk(sk);
        u32 srtt = (ts->srtt_us >> 3) / 1000;
        const struct inet_sock *inet = inet_sk(sk);

        /* filters */
        u32 saddr = 0;
        u32 daddr = 0;
        u16 family = 0;

        bpf_probe_read_kernel(&family, sizeof(family), (void *)&sk->__sk_common.skc_family);
        if (family != AF_INET) { return 0; }

        bpf_probe_read_kernel(&saddr, sizeof(saddr), (void *)&inet->inet_saddr);
        bpf_probe_read_kernel(&daddr, sizeof(daddr), (void *)&inet->inet_daddr);

        u32 laddr = __LOCAL_ADDRESS__;
        // u32 laddr = 0x1300a8c0;

        rtt_key_t key;

        if (saddr == laddr) {
          key.addr = daddr;
          key.direction = DESTINATION;
        } else if (daddr == laddr) {
          key.addr = saddr;
          key.direction = SOURCE;
        } else {
          return 0;
        }

        key.slot = bpf_log2l(srtt);
        hist_srtt.atomic_increment(key);
        return 0;
      }

  - name: tcpretrans
    metrics:
      counters:
        - name: tcp_retransmissions
          help: TCP retransmissions
          table: tcp_retransmissions
          labels:
            - name: addr
              size: 8
              decoders:
                - name: inet_ip
            - name: direction
              size: 8
              decoders:
                - name: uint
                - name: static_map
                  static_map:
                    1: source
                    2: destination
            - name: state
              size: 8
              decoders:
                - name: uint
                - name: static_map
                  static_map:
                    1: ESTABLISHED
                    2: SYN_SENT
                    3: SYN_RECV
                    4: FIN_WAIT1
                    5: FIN_WAIT2
                    6: TIME_WAIT
                    7: CLOSE
                    8: CLOSE_WAIT
                    9: LAST_ACK
                    10: LISTEN
                    11: CLOSING
                    12: NEW_SYN_RECV
    kprobes:
      tcp_retransmit_skb: trace_retransmit
    code: |
      #include <uapi/linux/ptrace.h>
      #include <linux/tcp.h>
      #include <net/sock.h>
      #include <net/inet_sock.h>
      #include <bcc/proto.h>

      typedef struct rtr_key {
        u64 addr;
        u64 direction;
        u64 state;
      } rtr_key_t;

      // Histograms to record TCP RTT
      BPF_HASH(tcp_retransmissions, rtr_key_t, u64, 100000);

      #define SOURCE 1
      #define DESTINATION 2

      int trace_retransmit(struct pt_regs *ctx, struct sock *sk, struct sk_buff *skb)
      {
        if (sk == NULL) { return 0; }

        u16 family = sk->__sk_common.skc_family;
        if (family != AF_INET) { return 0; }

        u32 saddr = sk->__sk_common.skc_rcv_saddr;
        u32 daddr = sk->__sk_common.skc_daddr;
        char state = sk->__sk_common.skc_stat

        u32 laddr = __LOCAL_ADDRESS__;
        // u32 laddr = 0x1300a8c0;

        rtr_key_t key;

        if (saddr == laddr) {
          key.addr = daddr;
          key.direction = DESTINATION;
        } else if (daddr == laddr) {
          key.addr = saddr;
          key.direction = SOURCE;
        } else {
          return 0;
        }

        key.state = state;
        tcp_retransmissions.atomic_increment(key);
        return 0;
      }
